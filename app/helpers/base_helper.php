<?php	/**	* Filename: Codeigniter Base Helper	* Creator: Egar Rizki [ Ch0c0-ID ]	* Copyright: Egar Rizki [ Ch0c0-ID ]	* Date: 29 November 2014	**/	//Keluarkan filenya utk didownload user	function _push_file($lokasi, $nama) {		if(is_file($lokasi)) {			//diperlukan untuk browser IE			if(ini_get('zlib.output_compression')) {				ini_set('zlib.output_compression', 'Off');			}			//dapatkan tipe mime menggunakan ekstensi file			//$this->load->helper('file');			//codeigniter instance class			$ci = &get_instance();			$ci->load->helper('file');			//gunakan tipe mime dari codeigniter			$mime = get_mime_by_extension($lokasi);			//bangun headernya untuk mempush out filenya dengan benar			header('Pragma: public');			header('Expires: 0');			header('Cache-Control: must-revalidate, post-check=0, pre-check=0');			header('Last-Modified: '.gmdate('D, d M Y H:i:s', filemtime($lokasi)).' GMT');			header('Cache-Control: private',false);			header('Content-Type: '.$mime);			header('Content-Disposition: attachment; filename="'.basename($nama).'"');			header('Content-Transfer-Encoding: binary');			header('Content-Length: '.filesize($lokasi));			header('Connection: close');			readfile($lokasi);			exit();		}	}	//kompresi data array untuk mempercepat transmit data  	function compress_array($array, $compress=0, $isi='', $tab=1) {		//jika tidak terdapat data array pada isinya maka buat data array baru		if(!$isi) {			$teks = 'array(';		}		//data random yg akan digunakan nanti		$n = rand();		$run[$n] = 0;		//replace tiap tab		for($i = 0; $i < $tab; $i++) {			$t .= "\t";		}			//validasi data			foreach($array as $key => $value) {				if(!$run[$n]) {					$c = '';				} else {					$c = ', ';				}				$run[$n]++;				//jika data array tidak kosong maka lanjutkan proses				if(is_array($value)) {					$teks .= $c . "\n" . $t . '\'' . $key . '\' => array('.Array2Txt($value,$compress,1,$tab+1);					continue 1;				}				//replace tiap enter / baris baru				$teks .= $c . "\n" . $t . '\'' . $key . '\' => \'' . $value . '\'';			}			//tutup data array			if(!$isi) {				$teks .= ');' . "\n";			} else {				$teks .= ')';			}			//jika data array belum dikompres, maka lakukan kompresi data array tersebut			//jika data array telah dikompres, maka kembalikan hasilnya			if($compress) {				return gzcompress($teks, 9);			} else {				return $teks;			}	}	//dekompresi data array yg dikompres untuk diproses	function decompress_array($array, $decompress=0) {		//jika data array tidak valid maka kembalikan hasilnya		if(!$array) {			return [];		}		//dekompresi data array		if($decompress) {			eval('$hasil = '.gzuncompress($array));			return $hasil;		} else {			//jika data tidak valid, maka hentikan proses dekompresi			if(!eval('$hasil = '.$array)) {				print '<p>Data Array tidak valid !</p>';				print $array;				exit;			}			return $hasil;		}	//ubah null menjadi underscore _	function convertnull($value) {		return isset($value) ? $value : "_";	}	//encode URL menggunakan base64	function encodeurl($data) {		//jika data tidak kosong maka lanjutkan proses		if($data !== "") {			return strtr(rtrim(base64_encode($data), '='), '+/', '-_');		} else {			//jika data kosong maka hentikan proses			return "Data URL tidak valid !";			exit;		}	}	//decode URL menggunakan base64	function decodeurl($base64) {		//validasi data base64		if(strtr(rtrim(base64_encode($data), '='), '+/', '-_') == $data) {			return base64_decode(strtr($base64, '-_', '+/'));		} else {			//jika data bukan base64 maka hentikan proses			return "Data URL tidak valid !";			exit;		}	}	//cek data array telah diasosiasikan atau tidak	function asosiasi_array($array) {		//jika datanya adalah array dan tidak kosong		if(is_array($array) && !empty($array)) {			//cek terdapat iterator atau tidak pada data array tersebut			for($iterator = count($array) - 1; $iterator; $iterator--)				//jika tidak terdapat iterator pada data array tersebut				if(!array_key_exists($iterator, $array)) {					//kembalikan hasilnya true					return true;				}			//jika tidak ada, kembalikan hasilnya false			return !array_key_exists(0, $array);		}		//kembalikan hasilnya false jika tidak ada		return false;	}	//strip karakter slash(/)	function stripslash($value) {		//jika magic_quotes_gpc nya aktif maka periksa datanya		if(get_magic_quotes_gpc() != 0) {			//jika datanya adalah array			if(is_array($value)) {				//jika data array telah diasosiasikan				if(asosiasi_array($value)) {					//lakukan strip jika ditemukan slash					foreach($value as $k => $v)						$tmp_val[$k] = stripslashes($v);					//kembalikan hasilnya					$value = $tmp_val;				} else {					//jika data array tidak diasosiasikan maka lakukan strip dan kembalikan hasilnya					for($j = 0; $j < sizeof($value); $j++)						$value[$j] = stripslashes($value[$j]);				}			} else {				//jika datanya bukan array maka lakukan strip dan kembalikan hasilnya				$value = stripslashes($value);			}		}		//jika tidak terdapat slash pada datanya kembalikan hasilnya		return $value;	}}	class RC4 {		/**		* ======================================================		* Begin RC4		* Created: Egar Rizki [ Ch0c0-ID ]		* Copyright: Egar Rizki [ Ch0c0-ID ]		* Date: 29 Nov 2014		* ======================================================		**/			//variabel utk permutasi vektor		private static $S = [];			//tukar nilai saat terjadi perubahan vektor		private static function swap(&$v1, &$v2) {			$v1 = $v1 ^ $v2;			$v2 = $v1 ^ $v2;			$v1 = $v1 ^ $v2;		}			//buat dan kembalikan hasil perubahan vektor untuk keynya		private static function KSA($key) {			$idx = crc32($key);				if(!isset(self::$S[$idx])) {				$S = range(0, 255);				$j = 0;				$n = strlen($key);					for($i = 0; $i < 256; $i++) {					$char = ord($key{$i % $n});					$j =($j + $S[$i] + $char) % 256;						self::swap($S[$i], $S[$j]);				}					self::$S[$idx] = $S;			}				return self::$S[$idx];		}			//enkripsi data		public static function encrypt($key, $data) {			$S = self::KSA($key);			$n = strlen($data);			$i = $j = 0;			$data = str_split($data, 1);				for($m = 0; $m < $n; $m++) {				$i =($i + 1) % 256;				$j =($j + $S[$i]) % 256;					self::swap($S[$i], $S[$j]);					$char = ord($data{$m});				$char = $S[($S[$i] + $S[$j]) % 256] ^ $char;				$data[$m] = chr($char);			}				$data = implode("", $data);			return $data;		}			//dekripsi data		public static function decrypt($key, $data) {			$data = self::encrypt($key, $data);				return $data;		}			/**		* ======================================================		* End Of RC4		* ======================================================		**/	}?>